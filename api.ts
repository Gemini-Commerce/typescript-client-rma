/* tslint:disable */
/* eslint-disable */
/**
 * RMA Service
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: info@gemini-commerce.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CreateReturnRequestProduct
 */
export interface CreateReturnRequestProduct {
    /**
     * 
     * @type {string}
     * @memberof CreateReturnRequestProduct
     */
    'grn': string;
    /**
     * 
     * @type {string}
     * @memberof CreateReturnRequestProduct
     */
    'quantity': string;
    /**
     * 
     * @type {string}
     * @memberof CreateReturnRequestProduct
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateReturnRequestProduct
     */
    'note'?: string;
}
/**
 * 
 * @export
 * @interface EditNoteRequestPayload
 */
export interface EditNoteRequestPayload {
    /**
     * 
     * @type {string}
     * @memberof EditNoteRequestPayload
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditNoteRequestPayload
     */
    'note'?: string;
}
/**
 * 
 * @export
 * @interface ListReturnsRequestFilter
 */
export interface ListReturnsRequestFilter {
    /**
     * 
     * @type {Array<string>}
     * @memberof ListReturnsRequestFilter
     */
    'searchTerms'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListReturnsRequestFilter
     */
    'returnIds'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListReturnsRequestFilter
     */
    'returnStatus'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListReturnsRequestFilter
     */
    'orderGrns'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListReturnsRequestFilter
     */
    'orderNumbers'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListReturnsRequestFilter
     */
    'orderItemGrns'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListReturnsRequestFilter
     */
    'orderItemSkus'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListReturnsRequestFilter
     */
    'customerGrns'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListReturnsRequestFilter
     */
    'customerEmails'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ListReturnsRequestFilter
     */
    'createdAtStart'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListReturnsRequestFilter
     */
    'createdAtEnd'?: string;
}
/**
 * 
 * @export
 * @interface OrderDataSubtotal
 */
export interface OrderDataSubtotal {
    /**
     * 
     * @type {OrderDataSubtotalCode}
     * @memberof OrderDataSubtotal
     */
    'code'?: OrderDataSubtotalCode;
    /**
     * 
     * @type {RmaMoney}
     * @memberof OrderDataSubtotal
     */
    'value'?: RmaMoney;
}


/**
 *  - ITEMS: gross discount items amount.  - ITEMS_DISCOUNTED: discounted items amount.  - DISCOUNT: discount amount. It is a NEGATIVE amount.
 * @export
 * @enum {string}
 */

export const OrderDataSubtotalCode = {
    Unknown: 'UNKNOWN',
    Payment: 'PAYMENT',
    Shipment: 'SHIPMENT',
    Tax: 'TAX',
    Items: 'ITEMS',
    ItemsDiscounted: 'ITEMS_DISCOUNTED',
    Discount: 'DISCOUNT'
} as const;

export type OrderDataSubtotalCode = typeof OrderDataSubtotalCode[keyof typeof OrderDataSubtotalCode];


/**
 * 
 * @export
 * @interface OrderDataTotal
 */
export interface OrderDataTotal {
    /**
     * 
     * @type {OrderDataTotalCode}
     * @memberof OrderDataTotal
     */
    'code'?: OrderDataTotalCode;
    /**
     * 
     * @type {RmaMoney}
     * @memberof OrderDataTotal
     */
    'value'?: RmaMoney;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const OrderDataTotalCode = {
    Unknown: 'UNKNOWN',
    Ordered: 'ORDERED',
    Paid: 'PAID',
    Refunded: 'REFUNDED'
} as const;

export type OrderDataTotalCode = typeof OrderDataTotalCode[keyof typeof OrderDataTotalCode];


/**
 * 
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    '@type'?: string;
}
/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
 * @export
 * @enum {string}
 */

export const ProtobufNullValue = {
    NullValue: 'NULL_VALUE'
} as const;

export type ProtobufNullValue = typeof ProtobufNullValue[keyof typeof ProtobufNullValue];


/**
 * 
 * @export
 * @interface RmaAddNoteRequest
 */
export interface RmaAddNoteRequest {
    /**
     * 
     * @type {string}
     * @memberof RmaAddNoteRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof RmaAddNoteRequest
     */
    'returnId': string;
    /**
     * 
     * @type {string}
     * @memberof RmaAddNoteRequest
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof RmaAddNoteRequest
     */
    'note': string;
}
/**
 * 
 * @export
 * @interface RmaApproveReturnRequest
 */
export interface RmaApproveReturnRequest {
    /**
     * 
     * @type {string}
     * @memberof RmaApproveReturnRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof RmaApproveReturnRequest
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof RmaApproveReturnRequest
     */
    'refundShippingCost': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RmaApproveReturnRequest
     */
    'refundPaymentCost': boolean;
    /**
     * 
     * @type {Array<RmaApproveReturnRequestItem>}
     * @memberof RmaApproveReturnRequest
     */
    'items': Array<RmaApproveReturnRequestItem>;
}
/**
 * 
 * @export
 * @interface RmaApproveReturnRequestItem
 */
export interface RmaApproveReturnRequestItem {
    /**
     * 
     * @type {string}
     * @memberof RmaApproveReturnRequestItem
     */
    'grn': string;
    /**
     * 
     * @type {string}
     * @memberof RmaApproveReturnRequestItem
     */
    'quantity': string;
}
/**
 * 
 * @export
 * @interface RmaCancelReturnRequest
 */
export interface RmaCancelReturnRequest {
    /**
     * 
     * @type {string}
     * @memberof RmaCancelReturnRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof RmaCancelReturnRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface RmaConfirmReturnApproveItemsRequest
 */
export interface RmaConfirmReturnApproveItemsRequest {
    /**
     * 
     * @type {string}
     * @memberof RmaConfirmReturnApproveItemsRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof RmaConfirmReturnApproveItemsRequest
     */
    'id': string;
    /**
     * 
     * @type {Array<RmaConfirmReturnApproveItemsRequestItem>}
     * @memberof RmaConfirmReturnApproveItemsRequest
     */
    'items': Array<RmaConfirmReturnApproveItemsRequestItem>;
}
/**
 * 
 * @export
 * @interface RmaConfirmReturnApproveItemsRequestItem
 */
export interface RmaConfirmReturnApproveItemsRequestItem {
    /**
     * 
     * @type {string}
     * @memberof RmaConfirmReturnApproveItemsRequestItem
     */
    'grn': string;
    /**
     * 
     * @type {string}
     * @memberof RmaConfirmReturnApproveItemsRequestItem
     */
    'quantity': string;
}
/**
 * 
 * @export
 * @interface RmaCreateReturnRequest
 */
export interface RmaCreateReturnRequest {
    /**
     * 
     * @type {string}
     * @memberof RmaCreateReturnRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof RmaCreateReturnRequest
     */
    'orderGrn': string;
    /**
     * 
     * @type {Array<CreateReturnRequestProduct>}
     * @memberof RmaCreateReturnRequest
     */
    'products': Array<CreateReturnRequestProduct>;
    /**
     * 
     * @type {RmaRefundMethod}
     * @memberof RmaCreateReturnRequest
     */
    'preferredRefundMethod': RmaRefundMethod;
    /**
     * 
     * @type {boolean}
     * @memberof RmaCreateReturnRequest
     */
    'refundShippingCost'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RmaCreateReturnRequest
     */
    'refundPaymentCost'?: boolean;
    /**
     * 
     * @type {RmaCustomerInfo}
     * @memberof RmaCreateReturnRequest
     */
    'customerInfo'?: RmaCustomerInfo;
    /**
     * 
     * @type {RmaPostalAddress}
     * @memberof RmaCreateReturnRequest
     */
    'returnAddress'?: RmaPostalAddress;
    /**
     * 
     * @type {string}
     * @memberof RmaCreateReturnRequest
     */
    'note'?: string;
}


/**
 * Stands for Albania, not all ;-)
 * @export
 * @enum {string}
 */

export const RmaCurrency = {
    Xxx: 'XXX',
    All: 'ALL',
    Dzd: 'DZD',
    Ars: 'ARS',
    Aud: 'AUD',
    Bsd: 'BSD',
    Bhd: 'BHD',
    Bdt: 'BDT',
    Amd: 'AMD',
    Bbd: 'BBD',
    Bmd: 'BMD',
    Btn: 'BTN',
    Bob: 'BOB',
    Bwp: 'BWP',
    Bzd: 'BZD',
    Sbd: 'SBD',
    Bnd: 'BND',
    Mmk: 'MMK',
    Bif: 'BIF',
    Khr: 'KHR',
    Cad: 'CAD',
    Cve: 'CVE',
    Kyd: 'KYD',
    Lkr: 'LKR',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Kmf: 'KMF',
    Crc: 'CRC',
    Hrk: 'HRK',
    Cup: 'CUP',
    Czk: 'CZK',
    Dkk: 'DKK',
    Dop: 'DOP',
    Svc: 'SVC',
    Etb: 'ETB',
    Ern: 'ERN',
    Fkp: 'FKP',
    Fjd: 'FJD',
    Djf: 'DJF',
    Gmd: 'GMD',
    Gip: 'GIP',
    Gtq: 'GTQ',
    Gnf: 'GNF',
    Gyd: 'GYD',
    Htg: 'HTG',
    Hnl: 'HNL',
    Hkd: 'HKD',
    Huf: 'HUF',
    Isk: 'ISK',
    Inr: 'INR',
    Idr: 'IDR',
    Irr: 'IRR',
    Iqd: 'IQD',
    Ils: 'ILS',
    Jmd: 'JMD',
    Jpy: 'JPY',
    Kzt: 'KZT',
    Jod: 'JOD',
    Kes: 'KES',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kgs: 'KGS',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lsl: 'LSL',
    Lrd: 'LRD',
    Lyd: 'LYD',
    Ltl: 'LTL',
    Mop: 'MOP',
    Mwk: 'MWK',
    Myr: 'MYR',
    Mvr: 'MVR',
    Mro: 'MRO',
    Mur: 'MUR',
    Mxn: 'MXN',
    Mnt: 'MNT',
    Mdl: 'MDL',
    Mad: 'MAD',
    Omr: 'OMR',
    Nad: 'NAD',
    Npr: 'NPR',
    Ang: 'ANG',
    Awg: 'AWG',
    Vuv: 'VUV',
    Nzd: 'NZD',
    Nio: 'NIO',
    Ngn: 'NGN',
    Nok: 'NOK',
    Pkr: 'PKR',
    Pab: 'PAB',
    Pgk: 'PGK',
    Pyg: 'PYG',
    Pen: 'PEN',
    Php: 'PHP',
    Qar: 'QAR',
    Rub: 'RUB',
    Rwf: 'RWF',
    Shp: 'SHP',
    Std: 'STD',
    Sar: 'SAR',
    Scr: 'SCR',
    Sll: 'SLL',
    Sgd: 'SGD',
    Vnd: 'VND',
    Sos: 'SOS',
    Zar: 'ZAR',
    Ssp: 'SSP',
    Szl: 'SZL',
    Sek: 'SEK',
    Chf: 'CHF',
    Syp: 'SYP',
    Thb: 'THB',
    Top: 'TOP',
    Ttd: 'TTD',
    Aed: 'AED',
    Tnd: 'TND',
    Ugx: 'UGX',
    Mkd: 'MKD',
    Egp: 'EGP',
    Gbp: 'GBP',
    Tzs: 'TZS',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Wst: 'WST',
    Yer: 'YER',
    Twd: 'TWD',
    Cuc: 'CUC',
    Zwl: 'ZWL',
    Tmt: 'TMT',
    Ghs: 'GHS',
    Vef: 'VEF',
    Sdg: 'SDG',
    Uyi: 'UYI',
    Rsd: 'RSD',
    Mzn: 'MZN',
    Azn: 'AZN',
    Ron: 'RON',
    Che: 'CHE',
    Chw: 'CHW',
    Try: 'TRY',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xof: 'XOF',
    Xpf: 'XPF',
    Xba: 'XBA',
    Xbb: 'XBB',
    Xbc: 'XBC',
    Xbd: 'XBD',
    Xau: 'XAU',
    Xdr: 'XDR',
    Xag: 'XAG',
    Xpt: 'XPT',
    Xpd: 'XPD',
    Xua: 'XUA',
    Zmw: 'ZMW',
    Srd: 'SRD',
    Mga: 'MGA',
    Cou: 'COU',
    Afn: 'AFN',
    Tjs: 'TJS',
    Aoa: 'AOA',
    Byr: 'BYR',
    Bgn: 'BGN',
    Cdf: 'CDF',
    Bam: 'BAM',
    Eur: 'EUR',
    Mxv: 'MXV',
    Uah: 'UAH',
    Gel: 'GEL',
    Bov: 'BOV',
    Pln: 'PLN',
    Brl: 'BRL',
    Clf: 'CLF',
    Xsu: 'XSU',
    Usn: 'USN'
} as const;

export type RmaCurrency = typeof RmaCurrency[keyof typeof RmaCurrency];


/**
 * 
 * @export
 * @interface RmaCustomerInfo
 */
export interface RmaCustomerInfo {
    /**
     * 
     * @type {string}
     * @memberof RmaCustomerInfo
     */
    'firstname'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaCustomerInfo
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaCustomerInfo
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaCustomerInfo
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaCustomerInfo
     */
    'grn'?: string;
}
/**
 * 
 * @export
 * @interface RmaDeleteNoteRequest
 */
export interface RmaDeleteNoteRequest {
    /**
     * 
     * @type {string}
     * @memberof RmaDeleteNoteRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof RmaDeleteNoteRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface RmaEditNoteRequest
 */
export interface RmaEditNoteRequest {
    /**
     * 
     * @type {string}
     * @memberof RmaEditNoteRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof RmaEditNoteRequest
     */
    'id': string;
    /**
     * 
     * @type {EditNoteRequestPayload}
     * @memberof RmaEditNoteRequest
     */
    'payload'?: EditNoteRequestPayload;
    /**
     * 
     * @type {string}
     * @memberof RmaEditNoteRequest
     */
    'payloadMask'?: string;
}
/**
 * 
 * @export
 * @interface RmaGetReturnRequest
 */
export interface RmaGetReturnRequest {
    /**
     * 
     * @type {string}
     * @memberof RmaGetReturnRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof RmaGetReturnRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface RmaListNotesByReturnIdRequest
 */
export interface RmaListNotesByReturnIdRequest {
    /**
     * 
     * @type {string}
     * @memberof RmaListNotesByReturnIdRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof RmaListNotesByReturnIdRequest
     */
    'returnId': string;
    /**
     * 
     * @type {number}
     * @memberof RmaListNotesByReturnIdRequest
     */
    'pageSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof RmaListNotesByReturnIdRequest
     */
    'pageToken'?: string;
    /**
     * 
     * @type {Array<RmaListNotesByReturnIdRequestSort>}
     * @memberof RmaListNotesByReturnIdRequest
     */
    'sorts'?: Array<RmaListNotesByReturnIdRequestSort>;
}
/**
 * 
 * @export
 * @interface RmaListNotesByReturnIdRequestSort
 */
export interface RmaListNotesByReturnIdRequestSort {
    /**
     * evaluation_order is the order in which the sort will be applied. The lower the number, the earlier the sort will be applied.
     * @type {number}
     * @memberof RmaListNotesByReturnIdRequestSort
     */
    'evaluationOrder': number;
    /**
     * 
     * @type {RmaListNotesByReturnIdRequestSortSortField}
     * @memberof RmaListNotesByReturnIdRequestSort
     */
    'field': RmaListNotesByReturnIdRequestSortSortField;
    /**
     * 
     * @type {RmaSortOrder}
     * @memberof RmaListNotesByReturnIdRequestSort
     */
    'order'?: RmaSortOrder;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RmaListNotesByReturnIdRequestSortSortField = {
    Unknown: 'UNKNOWN',
    Date: 'DATE'
} as const;

export type RmaListNotesByReturnIdRequestSortSortField = typeof RmaListNotesByReturnIdRequestSortSortField[keyof typeof RmaListNotesByReturnIdRequestSortSortField];


/**
 * 
 * @export
 * @interface RmaListNotesByReturnIdResponse
 */
export interface RmaListNotesByReturnIdResponse {
    /**
     * 
     * @type {Array<RmaNoteResponse>}
     * @memberof RmaListNotesByReturnIdResponse
     */
    'notes'?: Array<RmaNoteResponse>;
    /**
     * 
     * @type {string}
     * @memberof RmaListNotesByReturnIdResponse
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface RmaListReturnsRequest
 */
export interface RmaListReturnsRequest {
    /**
     * 
     * @type {string}
     * @memberof RmaListReturnsRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {number}
     * @memberof RmaListReturnsRequest
     */
    'pageSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof RmaListReturnsRequest
     */
    'pageToken'?: string;
    /**
     * 
     * @type {Array<RmaListReturnsRequestSort>}
     * @memberof RmaListReturnsRequest
     */
    'sorts'?: Array<RmaListReturnsRequestSort>;
    /**
     * 
     * @type {string}
     * @memberof RmaListReturnsRequest
     */
    'filterMask'?: string;
    /**
     * 
     * @type {ListReturnsRequestFilter}
     * @memberof RmaListReturnsRequest
     */
    'filter'?: ListReturnsRequestFilter;
}
/**
 * 
 * @export
 * @interface RmaListReturnsRequestSort
 */
export interface RmaListReturnsRequestSort {
    /**
     * evaluation_order is the order in which the sort will be applied. The lower the number, the earlier the sort will be applied.
     * @type {number}
     * @memberof RmaListReturnsRequestSort
     */
    'evaluationOrder': number;
    /**
     * 
     * @type {RmaListReturnsRequestSortSortField}
     * @memberof RmaListReturnsRequestSort
     */
    'field': RmaListReturnsRequestSortSortField;
    /**
     * 
     * @type {RmaSortOrder}
     * @memberof RmaListReturnsRequestSort
     */
    'order'?: RmaSortOrder;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RmaListReturnsRequestSortSortField = {
    Unknown: 'UNKNOWN',
    Date: 'DATE'
} as const;

export type RmaListReturnsRequestSortSortField = typeof RmaListReturnsRequestSortSortField[keyof typeof RmaListReturnsRequestSortSortField];


/**
 * 
 * @export
 * @interface RmaListReturnsResponse
 */
export interface RmaListReturnsResponse {
    /**
     * 
     * @type {Array<RmaReturnResponse>}
     * @memberof RmaListReturnsResponse
     */
    'returns'?: Array<RmaReturnResponse>;
    /**
     * 
     * @type {string}
     * @memberof RmaListReturnsResponse
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface RmaMoney
 */
export interface RmaMoney {
    /**
     * The whole units of the amount. For example if `currencyCode` is `\"USD\"`, then 1 unit is one US dollar.
     * @type {string}
     * @memberof RmaMoney
     */
    'units'?: string;
    /**
     * Number of micro (10^-6) units of the amount. The value must be between -999,999 and +999,999 inclusive. If `units` is positive, `micros` must be positive or zero. If `units` is zero, `micros` can be positive, zero, or negative. If `units` is negative, `micros` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `micros`=-750,000.
     * @type {number}
     * @memberof RmaMoney
     */
    'micros'?: number;
}
/**
 * 
 * @export
 * @interface RmaNoteResponse
 */
export interface RmaNoteResponse {
    /**
     * 
     * @type {string}
     * @memberof RmaNoteResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaNoteResponse
     */
    'grn'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaNoteResponse
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaNoteResponse
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaNoteResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaNoteResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaNoteResponse
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface RmaOrderData
 */
export interface RmaOrderData {
    /**
     * 
     * @type {string}
     * @memberof RmaOrderData
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaOrderData
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaOrderData
     */
    'grn'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaOrderData
     */
    'number'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaOrderData
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaOrderData
     */
    'channel'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaOrderData
     */
    'market'?: string;
    /**
     * 
     * @type {Array<RmaOrderDataItem>}
     * @memberof RmaOrderData
     */
    'items'?: Array<RmaOrderDataItem>;
    /**
     * 
     * @type {RmaCurrency}
     * @memberof RmaOrderData
     */
    'currency'?: RmaCurrency;
    /**
     * 
     * @type {{ [key: string]: OrderDataSubtotal; }}
     * @memberof RmaOrderData
     */
    'subtotals'?: { [key: string]: OrderDataSubtotal; };
    /**
     * 
     * @type {{ [key: string]: OrderDataTotal; }}
     * @memberof RmaOrderData
     */
    'totals'?: { [key: string]: OrderDataTotal; };
}


/**
 * 
 * @export
 * @interface RmaOrderDataItem
 */
export interface RmaOrderDataItem {
    /**
     * 
     * @type {string}
     * @memberof RmaOrderDataItem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaOrderDataItem
     */
    'productGrn'?: string;
    /**
     * 
     * @type {number}
     * @memberof RmaOrderDataItem
     */
    'qtyOrdered'?: number;
    /**
     * 
     * @type {number}
     * @memberof RmaOrderDataItem
     */
    'qtyCommitted'?: number;
    /**
     * 
     * @type {number}
     * @memberof RmaOrderDataItem
     */
    'qtyShipped'?: number;
    /**
     * 
     * @type {RmaMoney}
     * @memberof RmaOrderDataItem
     */
    'unitSalePrice'?: RmaMoney;
    /**
     * 
     * @type {RmaMoney}
     * @memberof RmaOrderDataItem
     */
    'unitListPrice'?: RmaMoney;
    /**
     * 
     * @type {RmaMoney}
     * @memberof RmaOrderDataItem
     */
    'unitVatAmount'?: RmaMoney;
    /**
     * 
     * @type {RmaMoney}
     * @memberof RmaOrderDataItem
     */
    'rowSalePrice'?: RmaMoney;
    /**
     * 
     * @type {RmaMoney}
     * @memberof RmaOrderDataItem
     */
    'rowListPrice'?: RmaMoney;
    /**
     * 
     * @type {RmaMoney}
     * @memberof RmaOrderDataItem
     */
    'rowVatAmount'?: RmaMoney;
    /**
     * 
     * @type {number}
     * @memberof RmaOrderDataItem
     */
    'vatPercentage'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RmaOrderDataItem
     */
    'vatInaccurate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RmaOrderDataItem
     */
    'vatCalculated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RmaOrderDataItem
     */
    'productName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaOrderDataItem
     */
    'productCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaOrderDataItem
     */
    'productSku'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaOrderDataItem
     */
    'productOptions'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaOrderDataItem
     */
    'productImg'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaOrderDataItem
     */
    'productData'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaOrderDataItem
     */
    'shipmentInfoReference'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RmaOrderDataItem
     */
    'promotionGrn'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof RmaOrderDataItem
     */
    'productIsVirtual'?: boolean;
}
/**
 * Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains).  In typical usage an address would be created via user input or from importing existing data, depending on the type of process.  Advice on address input / editing:  - Use an i18n-ready address widget such as    https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of   fields outside countries where that field is used.  For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
 * @export
 * @interface RmaPostalAddress
 */
export interface RmaPostalAddress {
    /**
     * The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision.  All new revisions **must** be backward compatible with old revisions.
     * @type {number}
     * @memberof RmaPostalAddress
     */
    'revision'?: number;
    /**
     * Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: \"CH\" for Switzerland.
     * @type {string}
     * @memberof RmaPostalAddress
     */
    'regionCode'?: string;
    /**
     * Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address\' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations.  If this value is not known, it should be omitted (rather than specifying a possibly incorrect default).  Examples: \"zh-Hant\", \"ja\", \"ja-Latn\", \"en\".
     * @type {string}
     * @memberof RmaPostalAddress
     */
    'languageCode'?: string;
    /**
     * Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
     * @type {string}
     * @memberof RmaPostalAddress
     */
    'postalCode'?: string;
    /**
     * Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like \"CEDEX\", optionally followed by a number (e.g. \"CEDEX 7\"), or just a number alone, representing the \"sector code\" (Jamaica), \"delivery area indicator\" (Malawi) or \"post office indicator\" (e.g. CÃ´te d\'Ivoire).
     * @type {string}
     * @memberof RmaPostalAddress
     */
    'sortingCode'?: string;
    /**
     * Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. \"Barcelona\" and not \"Catalonia\"). Many countries don\'t use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
     * @type {string}
     * @memberof RmaPostalAddress
     */
    'administrativeArea'?: string;
    /**
     * Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
     * @type {string}
     * @memberof RmaPostalAddress
     */
    'locality'?: string;
    /**
     * Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
     * @type {string}
     * @memberof RmaPostalAddress
     */
    'sublocality'?: string;
    /**
     * Unstructured address lines describing the lower levels of an address.  Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. \"Austin, TX\"), it is important that the line order is clear. The order of address lines should be \"envelope order\" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. \"ja\" for large-to-small ordering and \"ja-Latn\" or \"en\" for small-to-large). This way, the most specific line of an address can be selected based on the language.  The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved.  Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
     * @type {Array<string>}
     * @memberof RmaPostalAddress
     */
    'addressLines'?: Array<string>;
    /**
     * Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain \"care of\" information.
     * @type {Array<string>}
     * @memberof RmaPostalAddress
     */
    'recipients'?: Array<string>;
    /**
     * Optional. The name of the organization at the address.
     * @type {string}
     * @memberof RmaPostalAddress
     */
    'organization'?: string;
    /**
     * Optional.
     * @type {string}
     * @memberof RmaPostalAddress
     */
    'phoneNumber'?: string;
    /**
     * Optional.
     * @type {object}
     * @memberof RmaPostalAddress
     */
    'additionalInfo'?: object;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RmaRefundMethod = {
    Unknown: 'REFUND_METHOD_UNKNOWN',
    Offline: 'REFUND_METHOD_OFFLINE',
    Coupon: 'REFUND_METHOD_COUPON',
    SameAsPayment: 'REFUND_METHOD_SAME_AS_PAYMENT'
} as const;

export type RmaRefundMethod = typeof RmaRefundMethod[keyof typeof RmaRefundMethod];


/**
 * 
 * @export
 * @interface RmaRefundReturnRequest
 */
export interface RmaRefundReturnRequest {
    /**
     * 
     * @type {string}
     * @memberof RmaRefundReturnRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof RmaRefundReturnRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface RmaRejectReturnRequest
 */
export interface RmaRejectReturnRequest {
    /**
     * 
     * @type {string}
     * @memberof RmaRejectReturnRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof RmaRejectReturnRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface RmaReturnHistory
 */
export interface RmaReturnHistory {
    /**
     * 
     * @type {string}
     * @memberof RmaReturnHistory
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaReturnHistory
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaReturnHistory
     */
    'note'?: string;
}
/**
 * 
 * @export
 * @interface RmaReturnProduct
 */
export interface RmaReturnProduct {
    /**
     * 
     * @type {string}
     * @memberof RmaReturnProduct
     */
    'grn'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaReturnProduct
     */
    'reason'?: string;
    /**
     * 
     * @type {RmaReturnProductProperty}
     * @memberof RmaReturnProduct
     */
    'requested'?: RmaReturnProductProperty;
    /**
     * 
     * @type {RmaReturnProductProperty}
     * @memberof RmaReturnProduct
     */
    'approved'?: RmaReturnProductProperty;
    /**
     * 
     * @type {RmaReturnProductProperty}
     * @memberof RmaReturnProduct
     */
    'verified'?: RmaReturnProductProperty;
    /**
     * 
     * @type {RmaReturnProductProperty}
     * @memberof RmaReturnProduct
     */
    'refunded'?: RmaReturnProductProperty;
}
/**
 * 
 * @export
 * @interface RmaReturnProductProperty
 */
export interface RmaReturnProductProperty {
    /**
     * 
     * @type {string}
     * @memberof RmaReturnProductProperty
     */
    'quantity'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaReturnProductProperty
     */
    'note'?: string;
}
/**
 * 
 * @export
 * @interface RmaReturnResponse
 */
export interface RmaReturnResponse {
    /**
     * 
     * @type {string}
     * @memberof RmaReturnResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaReturnResponse
     */
    'grn'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaReturnResponse
     */
    'orderGrn'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaReturnResponse
     */
    'status'?: string;
    /**
     * 
     * @type {Array<RmaReturnProduct>}
     * @memberof RmaReturnResponse
     */
    'products'?: Array<RmaReturnProduct>;
    /**
     * 
     * @type {RmaRefundMethod}
     * @memberof RmaReturnResponse
     */
    'preferredRefundMethod'?: RmaRefundMethod;
    /**
     * 
     * @type {boolean}
     * @memberof RmaReturnResponse
     */
    'refundShippingCost'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RmaReturnResponse
     */
    'refundPaymentCost'?: boolean;
    /**
     * 
     * @type {RmaCustomerInfo}
     * @memberof RmaReturnResponse
     */
    'customerInfo'?: RmaCustomerInfo;
    /**
     * 
     * @type {RmaPostalAddress}
     * @memberof RmaReturnResponse
     */
    'returnAddress'?: RmaPostalAddress;
    /**
     * 
     * @type {string}
     * @memberof RmaReturnResponse
     */
    'note'?: string;
    /**
     * 
     * @type {Array<RmaReturnHistory>}
     * @memberof RmaReturnResponse
     */
    'history'?: Array<RmaReturnHistory>;
    /**
     * 
     * @type {string}
     * @memberof RmaReturnResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof RmaReturnResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {RmaOrderData}
     * @memberof RmaReturnResponse
     */
    'orderData'?: RmaOrderData;
}


/**
 * 
 * @export
 * @interface RmaSetReceivedItemsRequest
 */
export interface RmaSetReceivedItemsRequest {
    /**
     * 
     * @type {string}
     * @memberof RmaSetReceivedItemsRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof RmaSetReceivedItemsRequest
     */
    'id': string;
    /**
     * 
     * @type {Array<RmaSetReceivedItemsRequestItem>}
     * @memberof RmaSetReceivedItemsRequest
     */
    'items': Array<RmaSetReceivedItemsRequestItem>;
}
/**
 * 
 * @export
 * @interface RmaSetReceivedItemsRequestItem
 */
export interface RmaSetReceivedItemsRequestItem {
    /**
     * 
     * @type {string}
     * @memberof RmaSetReceivedItemsRequestItem
     */
    'grn': string;
    /**
     * 
     * @type {string}
     * @memberof RmaSetReceivedItemsRequestItem
     */
    'quantity': string;
}
/**
 * 
 * @export
 * @interface RmaSkipReturnStatusRequest
 */
export interface RmaSkipReturnStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof RmaSkipReturnStatusRequest
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof RmaSkipReturnStatusRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RmaSortOrder = {
    Desc: 'DESC',
    Asc: 'ASC'
} as const;

export type RmaSortOrder = typeof RmaSortOrder[keyof typeof RmaSortOrder];


/**
 * 
 * @export
 * @interface RpcStatus
 */
export interface RpcStatus {
    /**
     * 
     * @type {number}
     * @memberof RpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof RpcStatus
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof RpcStatus
     */
    'details'?: Array<ProtobufAny>;
}

/**
 * RmaApi - axios parameter creator
 * @export
 */
export const RmaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a note to an RMA
         * @param {RmaAddNoteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNote: async (body: RmaAddNoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addNote', 'body', body)
            const localVarPath = `/rma.Rma/AddNote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Approve a return
         * @param {RmaApproveReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveReturn: async (body: RmaApproveReturnRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('approveReturn', 'body', body)
            const localVarPath = `/rma.Rma/ApproveReturn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel a return
         * @param {RmaCancelReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelReturn: async (body: RmaCancelReturnRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('cancelReturn', 'body', body)
            const localVarPath = `/rma.Rma/CancelReturn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirm return approve items
         * @param {RmaConfirmReturnApproveItemsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmReturnApproveItems: async (body: RmaConfirmReturnApproveItemsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('confirmReturnApproveItems', 'body', body)
            const localVarPath = `/rma.Rma/ConfirmReturnApproveItems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a return
         * @param {RmaCreateReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReturn: async (body: RmaCreateReturnRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createReturn', 'body', body)
            const localVarPath = `/rma.Rma/CreateReturn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a note from an RMA
         * @param {RmaDeleteNoteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNote: async (body: RmaDeleteNoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('deleteNote', 'body', body)
            const localVarPath = `/rma.Rma/DeleteNote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a note on an RMA
         * @param {RmaEditNoteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNote: async (body: RmaEditNoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('editNote', 'body', body)
            const localVarPath = `/rma.Rma/EditNote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a return
         * @param {RmaGetReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturn: async (body: RmaGetReturnRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('getReturn', 'body', body)
            const localVarPath = `/rma.Rma/GetReturn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List notes by return id
         * @param {RmaListNotesByReturnIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotesByReturnId: async (body: RmaListNotesByReturnIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('listNotesByReturnId', 'body', body)
            const localVarPath = `/rma.Rma/ListNotesByReturnId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List returns
         * @param {RmaListReturnsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReturns: async (body: RmaListReturnsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('listReturns', 'body', body)
            const localVarPath = `/rma.Rma/ListReturns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refund a return
         * @param {RmaRefundReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundReturn: async (body: RmaRefundReturnRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('refundReturn', 'body', body)
            const localVarPath = `/rma.Rma/RefundReturn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reject a return
         * @param {RmaRejectReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectReturn: async (body: RmaRejectReturnRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('rejectReturn', 'body', body)
            const localVarPath = `/rma.Rma/RejectReturn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set received items
         * @param {RmaSetReceivedItemsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReceivedItems: async (body: RmaSetReceivedItemsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('setReceivedItems', 'body', body)
            const localVarPath = `/rma.Rma/SetReceivedItems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Skip a return status
         * @param {RmaSkipReturnStatusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipReturnStatus: async (body: RmaSkipReturnStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('skipReturnStatus', 'body', body)
            const localVarPath = `/rma.Rma/SkipReturnStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RmaApi - functional programming interface
 * @export
 */
export const RmaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RmaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a note to an RMA
         * @param {RmaAddNoteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNote(body: RmaAddNoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RmaNoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNote(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RmaApi.addNote']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Approve a return
         * @param {RmaApproveReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveReturn(body: RmaApproveReturnRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpcStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveReturn(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RmaApi.approveReturn']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Cancel a return
         * @param {RmaCancelReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelReturn(body: RmaCancelReturnRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelReturn(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RmaApi.cancelReturn']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Confirm return approve items
         * @param {RmaConfirmReturnApproveItemsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmReturnApproveItems(body: RmaConfirmReturnApproveItemsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmReturnApproveItems(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RmaApi.confirmReturnApproveItems']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create a return
         * @param {RmaCreateReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReturn(body: RmaCreateReturnRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RmaReturnResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReturn(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RmaApi.createReturn']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a note from an RMA
         * @param {RmaDeleteNoteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNote(body: RmaDeleteNoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNote(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RmaApi.deleteNote']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Edit a note on an RMA
         * @param {RmaEditNoteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editNote(body: RmaEditNoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RmaNoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editNote(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RmaApi.editNote']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get a return
         * @param {RmaGetReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReturn(body: RmaGetReturnRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RmaReturnResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReturn(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RmaApi.getReturn']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List notes by return id
         * @param {RmaListNotesByReturnIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNotesByReturnId(body: RmaListNotesByReturnIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RmaListNotesByReturnIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNotesByReturnId(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RmaApi.listNotesByReturnId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List returns
         * @param {RmaListReturnsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReturns(body: RmaListReturnsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RmaListReturnsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReturns(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RmaApi.listReturns']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Refund a return
         * @param {RmaRefundReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundReturn(body: RmaRefundReturnRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundReturn(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RmaApi.refundReturn']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Reject a return
         * @param {RmaRejectReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectReturn(body: RmaRejectReturnRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectReturn(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RmaApi.rejectReturn']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Set received items
         * @param {RmaSetReceivedItemsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setReceivedItems(body: RmaSetReceivedItemsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setReceivedItems(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RmaApi.setReceivedItems']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Skip a return status
         * @param {RmaSkipReturnStatusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skipReturnStatus(body: RmaSkipReturnStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skipReturnStatus(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RmaApi.skipReturnStatus']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RmaApi - factory interface
 * @export
 */
export const RmaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RmaApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a note to an RMA
         * @param {RmaAddNoteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNote(body: RmaAddNoteRequest, options?: any): AxiosPromise<RmaNoteResponse> {
            return localVarFp.addNote(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Approve a return
         * @param {RmaApproveReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveReturn(body: RmaApproveReturnRequest, options?: any): AxiosPromise<RpcStatus> {
            return localVarFp.approveReturn(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel a return
         * @param {RmaCancelReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelReturn(body: RmaCancelReturnRequest, options?: any): AxiosPromise<object> {
            return localVarFp.cancelReturn(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Confirm return approve items
         * @param {RmaConfirmReturnApproveItemsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmReturnApproveItems(body: RmaConfirmReturnApproveItemsRequest, options?: any): AxiosPromise<object> {
            return localVarFp.confirmReturnApproveItems(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a return
         * @param {RmaCreateReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReturn(body: RmaCreateReturnRequest, options?: any): AxiosPromise<RmaReturnResponse> {
            return localVarFp.createReturn(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a note from an RMA
         * @param {RmaDeleteNoteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNote(body: RmaDeleteNoteRequest, options?: any): AxiosPromise<object> {
            return localVarFp.deleteNote(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a note on an RMA
         * @param {RmaEditNoteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editNote(body: RmaEditNoteRequest, options?: any): AxiosPromise<RmaNoteResponse> {
            return localVarFp.editNote(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a return
         * @param {RmaGetReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturn(body: RmaGetReturnRequest, options?: any): AxiosPromise<RmaReturnResponse> {
            return localVarFp.getReturn(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List notes by return id
         * @param {RmaListNotesByReturnIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotesByReturnId(body: RmaListNotesByReturnIdRequest, options?: any): AxiosPromise<RmaListNotesByReturnIdResponse> {
            return localVarFp.listNotesByReturnId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List returns
         * @param {RmaListReturnsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReturns(body: RmaListReturnsRequest, options?: any): AxiosPromise<RmaListReturnsResponse> {
            return localVarFp.listReturns(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refund a return
         * @param {RmaRefundReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundReturn(body: RmaRefundReturnRequest, options?: any): AxiosPromise<object> {
            return localVarFp.refundReturn(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reject a return
         * @param {RmaRejectReturnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectReturn(body: RmaRejectReturnRequest, options?: any): AxiosPromise<object> {
            return localVarFp.rejectReturn(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set received items
         * @param {RmaSetReceivedItemsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReceivedItems(body: RmaSetReceivedItemsRequest, options?: any): AxiosPromise<object> {
            return localVarFp.setReceivedItems(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Skip a return status
         * @param {RmaSkipReturnStatusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipReturnStatus(body: RmaSkipReturnStatusRequest, options?: any): AxiosPromise<object> {
            return localVarFp.skipReturnStatus(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RmaApi - object-oriented interface
 * @export
 * @class RmaApi
 * @extends {BaseAPI}
 */
export class RmaApi extends BaseAPI {
    /**
     * 
     * @summary Add a note to an RMA
     * @param {RmaAddNoteRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaApi
     */
    public addNote(body: RmaAddNoteRequest, options?: RawAxiosRequestConfig) {
        return RmaApiFp(this.configuration).addNote(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Approve a return
     * @param {RmaApproveReturnRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaApi
     */
    public approveReturn(body: RmaApproveReturnRequest, options?: RawAxiosRequestConfig) {
        return RmaApiFp(this.configuration).approveReturn(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel a return
     * @param {RmaCancelReturnRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaApi
     */
    public cancelReturn(body: RmaCancelReturnRequest, options?: RawAxiosRequestConfig) {
        return RmaApiFp(this.configuration).cancelReturn(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Confirm return approve items
     * @param {RmaConfirmReturnApproveItemsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaApi
     */
    public confirmReturnApproveItems(body: RmaConfirmReturnApproveItemsRequest, options?: RawAxiosRequestConfig) {
        return RmaApiFp(this.configuration).confirmReturnApproveItems(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a return
     * @param {RmaCreateReturnRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaApi
     */
    public createReturn(body: RmaCreateReturnRequest, options?: RawAxiosRequestConfig) {
        return RmaApiFp(this.configuration).createReturn(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a note from an RMA
     * @param {RmaDeleteNoteRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaApi
     */
    public deleteNote(body: RmaDeleteNoteRequest, options?: RawAxiosRequestConfig) {
        return RmaApiFp(this.configuration).deleteNote(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a note on an RMA
     * @param {RmaEditNoteRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaApi
     */
    public editNote(body: RmaEditNoteRequest, options?: RawAxiosRequestConfig) {
        return RmaApiFp(this.configuration).editNote(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a return
     * @param {RmaGetReturnRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaApi
     */
    public getReturn(body: RmaGetReturnRequest, options?: RawAxiosRequestConfig) {
        return RmaApiFp(this.configuration).getReturn(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List notes by return id
     * @param {RmaListNotesByReturnIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaApi
     */
    public listNotesByReturnId(body: RmaListNotesByReturnIdRequest, options?: RawAxiosRequestConfig) {
        return RmaApiFp(this.configuration).listNotesByReturnId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List returns
     * @param {RmaListReturnsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaApi
     */
    public listReturns(body: RmaListReturnsRequest, options?: RawAxiosRequestConfig) {
        return RmaApiFp(this.configuration).listReturns(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refund a return
     * @param {RmaRefundReturnRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaApi
     */
    public refundReturn(body: RmaRefundReturnRequest, options?: RawAxiosRequestConfig) {
        return RmaApiFp(this.configuration).refundReturn(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reject a return
     * @param {RmaRejectReturnRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaApi
     */
    public rejectReturn(body: RmaRejectReturnRequest, options?: RawAxiosRequestConfig) {
        return RmaApiFp(this.configuration).rejectReturn(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set received items
     * @param {RmaSetReceivedItemsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaApi
     */
    public setReceivedItems(body: RmaSetReceivedItemsRequest, options?: RawAxiosRequestConfig) {
        return RmaApiFp(this.configuration).setReceivedItems(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Skip a return status
     * @param {RmaSkipReturnStatusRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RmaApi
     */
    public skipReturnStatus(body: RmaSkipReturnStatusRequest, options?: RawAxiosRequestConfig) {
        return RmaApiFp(this.configuration).skipReturnStatus(body, options).then((request) => request(this.axios, this.basePath));
    }
}



